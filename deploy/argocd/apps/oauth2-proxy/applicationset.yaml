---
# =============================================================================
# OAuth2 Proxy ApplicationSet - Wave 35 (Authentication)
# =============================================================================
# Déploie OAuth2 Proxy pour l'authentification OIDC avec Keycloak
# Utilisé en mode ext_authz avec Istio (auth seulement, pas de proxy du trafic)
# Docs: https://oauth2-proxy.github.io/oauth2-proxy/
# =============================================================================

apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: oauth2-proxy
  namespace: argo-cd
  annotations:
    argocd.argoproj.io/sync-wave: "35"
spec:
  goTemplate: true
  goTemplateOptions: ["missingkey=error"]

  generators:
    - merge:
        mergeKeys:
          - environment
        generators:
          - git:
              repoURL: https://github.com/gigi206/k8s
              revision: 'HEAD'
              files:
                - path: deploy/argocd/config/config.yaml
          - git:
              repoURL: https://github.com/gigi206/k8s
              revision: 'HEAD'
              files:
                - path: deploy/argocd/apps/oauth2-proxy/config/*.yaml

  template:
    metadata:
      name: oauth2-proxy
      namespace: argo-cd
      annotations:
        argocd.argoproj.io/sync-wave: "35"
    spec:
      project: default

      source:
        repoURL: https://oauth2-proxy.github.io/manifests
        targetRevision: '{{ .oauth2Proxy.version }}'
        chart: oauth2-proxy

      destination:
        server: https://kubernetes.default.svc
        namespace: oauth2-proxy

      syncPolicy:
        retry:
          limit: 10
          backoff:
            duration: 10s
            factor: 2
            maxDuration: 10m

  templatePatch: |
    spec:
      ignoreDifferences:
        - group: batch
          kind: Job
          jqPathExpressions:
            - .spec.selector
            - .spec.template.metadata.labels
        - group: external-secrets.io
          kind: ExternalSecret
          jqPathExpressions:
            - .spec.data[].remoteRef
            - .spec.target
        - group: gateway.networking.k8s.io
          kind: HTTPRoute
          jqPathExpressions:
            - .spec.parentRefs[].group
            - .spec.parentRefs[].kind
            - .spec.rules[].backendRefs[].group
            - .spec.rules[].backendRefs[].kind
            - .spec.rules[].backendRefs[].weight
      syncPolicy:
        syncOptions:
        {{- range .syncPolicy.syncOptions }}
          - {{ . }}
        {{- end }}
      {{- if .syncPolicy.automated.enabled }}
        automated:
          prune: {{ .syncPolicy.automated.prune }}
          selfHeal: {{ .syncPolicy.automated.selfHeal }}
      {{- end }}
      sources:
        {{- if .features.cilium.defaultDenyPodIngress.enabled }}
        # Source: Cilium internal ingress policy (pod-to-pod communication)
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/resources
          directory:
            include: "cilium-ingress-policy.yaml"
        {{- end }}
        {{- if .features.cilium.ingressPolicy.enabled }}
        # Source: Cilium ingress policy - conditional per Gateway provider
        {{- if eq .features.gatewayAPI.controller.provider "istio" }}
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/resources
          directory:
            include: "cilium-ingress-policy-istio.yaml"
        {{- else if eq .features.gatewayAPI.controller.provider "apisix" }}
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/resources
          directory:
            include: "cilium-ingress-policy-apisix.yaml"
        {{- else if eq .features.gatewayAPI.controller.provider "traefik" }}
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/resources
          directory:
            include: "cilium-ingress-policy-traefik.yaml"
        {{- else if eq .features.gatewayAPI.controller.provider "nginx-gwf" }}
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/resources
          directory:
            include: "cilium-ingress-policy-nginx-gwf.yaml"
        {{- else if eq .features.gatewayAPI.controller.provider "envoy-gateway" }}
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/resources
          directory:
            include: "cilium-ingress-policy-envoy-gateway.yaml"
        {{- end }}
        {{- end }}
        {{- if and .features.sso.enabled (eq .features.sso.provider "keycloak") }}
        # Source 2: SSO resources (Keycloak client Job) - only when SSO enabled
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/kustomize/sso
          kustomize:
            images:
              - 'curlimages/curl={{ .images.curl.repository }}:{{ .images.curl.tag }}'
            patches:
              - target:
                  kind: Job
                  name: oauth2-proxy-keycloak-client
                patch: |
                  - op: replace
                    path: /spec/template/spec/containers/0/env/0/value
                    value: {{ .common.domain }}
        {{- end }}
        # Source 2: Encrypted secrets (KSOPS)
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/secrets/{{ .environment }}
        {{- if .features.gatewayAPI.enabled }}
        {{- if .features.gatewayAPI.httpRoute.enabled }}
        # Source 3: HTTPRoute (Gateway API standard)
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/kustomize/httproute
          kustomize:
            patches:
              - target:
                  kind: HTTPRoute
                  name: oauth2-proxy
                patch: |
                  - op: replace
                    path: /spec/hostnames/0
                    value: oauth2.{{ .common.domain }}
                  - op: replace
                    path: /spec/parentRefs/0/namespace
                    value: '{{ .features.gatewayAPI.controller.gatewayNamespace }}'
                  {{- if eq .features.gatewayAPI.controller.provider "nginx-gwf" }}
                  # Add SnippetsFilter reference to inject OAuth2 locations at http.server level
                  - op: add
                    path: /spec/rules/0/filters
                    value:
                      - type: ExtensionRef
                        extensionRef:
                          group: gateway.nginx.org
                          kind: SnippetsFilter
                          name: oauth2-server-locations
                  {{- end }}
              - target:
                  kind: ReferenceGrant
                  name: allow-oauth2-proxy-httproute
                patch: |
                  - op: replace
                    path: /metadata/namespace
                    value: '{{ .features.gatewayAPI.controller.gatewayNamespace }}'
        {{- else if eq .features.gatewayAPI.controller.provider "apisix" }}
        # Source 3: APISIX native CRDs (when HTTPRoute disabled and provider is apisix)
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/kustomize/apisix
          kustomize:
            patches:
              - target:
                  kind: ApisixRoute
                  name: oauth2-proxy
                patch: |
                  - op: replace
                    path: /spec/http/0/match/hosts/0
                    value: oauth2.{{ .common.domain }}
        {{- end }}
        {{- end }}
        {{- if eq .features.gatewayAPI.controller.provider "traefik" }}
        # Source: Traefik Middleware for ForwardAuth (oauth2-proxy ext_authz)
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/kustomize/traefik-middleware
        {{- else if eq .features.gatewayAPI.controller.provider "nginx-gwf" }}
        # Source: NGINX Gateway Fabric SnippetsFilter for OAuth2 auth_request
        # Creates internal /oauth2/auth location and /oauth2/* proxy locations at http.server level
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/kustomize/nginx-gwf
        {{- end }}
        {{- if .features.kyverno.enabled }}
        # Source: Kyverno PolicyException (allows SA token mount for K8s API access)
        - repoURL: https://github.com/gigi206/k8s
          targetRevision: '{{ .git.revision }}'
          path: deploy/argocd/apps/oauth2-proxy/resources
          directory:
            include: "kyverno-policy-exception.yaml"
        {{- end }}
        # Source 4: Helm chart
        - repoURL: https://oauth2-proxy.github.io/manifests
          targetRevision: '{{ .oauth2Proxy.version }}'
          chart: oauth2-proxy
          helm:
            valuesObject:
              # Replica count
              replicaCount: {{ .oauth2Proxy.replicas | default 1 }}

              # Configuration for ext_authz mode
              config:
                # Use existing secret containing client-id, client-secret, cookie-secret
                existingSecret: oauth2-proxy-secrets
                cookieName: "_oauth2_proxy"

              extraArgs:
                # OIDC Provider (Keycloak)
                provider: oidc
                provider-display-name: "Keycloak"
                # Skip the "Sign in with Keycloak" button page
                skip-provider-button: "true"
                # Internal URL for OIDC discovery (server-to-server)
                # Note: Keycloak returns HTTPS URLs in discovery, so browser redirects work correctly
                oidc-issuer-url: "http://keycloak-service.keycloak.svc.cluster.local:8080/realms/k8s"
                # Internal URLs for server-to-server communication (more efficient than external)
                redeem-url: "http://keycloak-service.keycloak.svc.cluster.local:8080/realms/k8s/protocol/openid-connect/token"
                profile-url: "http://keycloak-service.keycloak.svc.cluster.local:8080/realms/k8s/protocol/openid-connect/userinfo"
                oidc-jwks-url: "http://keycloak-service.keycloak.svc.cluster.local:8080/realms/k8s/protocol/openid-connect/certs"

                # Redirect URL (OAuth2 Proxy's callback)
                redirect-url: "https://oauth2.{{ .common.domain }}/oauth2/callback"

                # PKCE (Proof Key for Code Exchange) - required by Keycloak
                code-challenge-method: S256

                # Cookie settings
                cookie-domain: ".{{ .common.domain }}"
                cookie-expire: "168h"
                cookie-refresh: "1h"
                cookie-samesite: "none"
                cookie-secure: "true"
                cookie-csrf-per-request: "false"
                cookie-csrf-expire: "5m"

                # Whitelist domains for redirects
                whitelist-domain: ".{{ .common.domain }}"

                # Email/user settings
                email-domain: "*"

                # Skip issuer verification (Keycloak returns external URL in discovery)
                # This is NOT about SSL - it's about accepting the URL mismatch
                # when using internal HTTP URLs while Keycloak advertises external HTTPS
                insecure-oidc-skip-issuer-verification: true

                # Upstream for health checks only (not used in ext_authz mode)
                upstream: "static://200"

                # Enable auth response headers
                set-xauthrequest: true
                set-authorization-header: true
                pass-access-token: true
                pass-authorization-header: true

                # Reverse proxy mode (for ext_authz)
                reverse-proxy: true

                {{- if and .features.sso.enabled (eq .features.sso.provider "keycloak") }}
                # CA file for TLS verification when connecting to Keycloak
                # Required for token refresh which uses external HTTPS URL
                provider-ca-file: "/etc/ssl/certs/root-ca.crt"
                {{- end }}

              # Service for ext_authz
              service:
                type: ClusterIP
                portNumber: 4180

              # Ingress disabled (we use HTTPRoute)
              ingress:
                enabled: false

              {{- if .features.monitoring.enabled }}
              # Prometheus metrics
              metrics:
                enabled: true
                servicemonitor:
                  enabled: true
                  labels:
                    release: "{{ .features.monitoring.release }}"
              {{- end }}

              {{- if and .features.sso.enabled (eq .features.sso.provider "keycloak") }}
              # Init container to wait for Keycloak OIDC discovery endpoint
              # Only when using local Keycloak as SSO provider
              extraInitContainers:
                - name: wait-for-keycloak
                  image: '{{ .images.curl.repository }}:{{ .images.curl.tag }}'
                  command:
                    - /bin/sh
                    - -c
                    - |
                      echo "Waiting for Keycloak OIDC discovery endpoint..."
                      until curl -sf http://keycloak-service.keycloak.svc.cluster.local:8080/realms/k8s/.well-known/openid-configuration > /dev/null 2>&1; do
                        echo "Keycloak not ready yet, waiting 5s..."
                        sleep 5
                      done
                      echo "Keycloak OIDC discovery endpoint is available!"
                  securityContext:
                    runAsNonRoot: true
                    runAsUser: 1000
                    allowPrivilegeEscalation: false
                    readOnlyRootFilesystem: true
                    capabilities:
                      drop: ["ALL"]
                    seccompProfile:
                      type: RuntimeDefault
                  {{- if .oauth2Proxy.waitForKeycloak }}
                  {{- if .oauth2Proxy.waitForKeycloak.resources }}
                  resources:
                    requests:
                      cpu: '{{ .oauth2Proxy.waitForKeycloak.resources.requests.cpu }}'
                      memory: '{{ .oauth2Proxy.waitForKeycloak.resources.requests.memory }}'
                    limits:
                      cpu: '{{ .oauth2Proxy.waitForKeycloak.resources.limits.cpu }}'
                      memory: '{{ .oauth2Proxy.waitForKeycloak.resources.limits.memory }}'
                  {{- end }}
                  {{- end }}

              # Mount root CA for TLS verification when refreshing tokens
              # OAuth2 Proxy uses external HTTPS URLs from OIDC discovery during token refresh
              extraVolumes:
                - name: root-ca
                  secret:
                    secretName: root-ca

              extraVolumeMounts:
                - name: root-ca
                  mountPath: /etc/ssl/certs/root-ca.crt
                  subPath: ca.crt
                  readOnly: true
              {{- end }}

              # Resources
              resources:
                requests:
                  cpu: {{ .oauth2Proxy.resources.requests.cpu | default "50m" }}
                  memory: {{ .oauth2Proxy.resources.requests.memory | default "64Mi" }}
                limits:
                  cpu: {{ .oauth2Proxy.resources.limits.cpu | default "100m" }}
                  memory: {{ .oauth2Proxy.resources.limits.memory | default "128Mi" }}

              # Security hardening (CIS/NSA compliance)
              # Disable SA token automount - oauth2-proxy doesn't need K8s API access
              {{- if .oauth2Proxy.serviceAccount }}
              serviceAccount:
                automountServiceAccountToken: {{ .oauth2Proxy.serviceAccount.automountServiceAccountToken | default true }}
              {{- end }}
